#include <iostream>   
#include <string>     

using namespace std;  

// Структура "Вагон" - описывает один вагон поезда
struct Wagon {
    int number;        // Номер вагона (0-999 по заданию)
    string cargo;      // Тип груза в вагоне (например, "Уголь", "Нефть")
    int weight;        // Вес груза в тоннах
    Wagon* next;       // Указатель на следующий вагон в составе

};

// Структура "Локомотив" - описывает локомотив и его состав
struct Locomotive {
    char code;          // Код локомотива - одна буква от A до Z
    Wagon* firstWagon;  // Указатель на первый вагон в составе этого локомотива
    Locomotive* next;   // Указатель на следующий локомотив в списке
};

// Функция создания нового вагона
Wagon* MAKE_WAGON(int number, string cargo, int weight) {
    // 1. Выделяем динамическую память под новый вагон
    Wagon* p = new Wagon;
    // 2. Заполняем поля созданного вагона переданными значениями
    p->number = number;  // Присваиваем номер
    p->cargo = cargo;    // Присваиваем тип груза
    p->weight = weight;  // Присваиваем вес

    // 3. Устанавливаем указатель next в nullptr (ничего не указывает)
    p->next = nullptr;
    // 4. Возвращаем указатель на созданный вагон
    return p;
}

// Функция создания нового локомотива
Locomotive* MAKE_LOCO(char code) {
    // 1. Выделяем память под новый локомотив
    Locomotive* p = new Locomotive;
    // 2. Заполняем поля локомотива
    p->code = code;          // Устанавливаем код локомотива
    // 3. Устанавливаем указатель на первый вагон в nullptr (состав пустой)
    p->firstWagon = nullptr;
    // 4. Пока не знаем, какой локомотив будет следующим в списке
    p->next = nullptr;
    // 5. Возвращаем указатель на созданный локомотив
    return p;
}

// Функция прицепки вагона к локомотиву (в конец состава)
void ATTACH_WAGON(Locomotive* loco, int number, string cargo, int weight) {
    // 1. Создаём новый вагон с заданными параметрами
    Wagon* newWagon = MAKE_WAGON(number, cargo, weight);
    // 2. Проверяем: если у локомотива ещё нет вагонов
    if (loco->firstWagon == nullptr) {
        // Делаем новый вагон ПЕРВЫМ вагоном в составе
        loco->firstWagon = newWagon;
    }
    else {
        // 3. Если вагоны уже есть, нужно найти ПОСЛЕДНИЙ вагон
        // Начинаем с первого вагона
        Wagon* p = loco->firstWagon;
        // Последний вагон - это тот, у которого next = nullptr
        while (p->next != nullptr) {
            p = p->next;  // Переходим к следующему вагону
        }
        //Теперь p указывает на последний вагон. Прицепляем новый вагон после него
        p->next = newWagon;
    }
}
// Функция просмотра состава локомотива
// Выводит: код локомотива, все его вагоны, количество вагонов и общий вес
void VIEW_LOCO(Locomotive* loco) {
    // 1. передан ли существующий локомотив
    if (loco == nullptr) {
        cout << "Локомотив не найден!" << endl;
        return; 
    }
    // 2. Выводим код локомотива
    cout << "Локомотив [" << loco->code << "]" << endl;
    // 3. Есть ли у локомотива вагоны
    if (loco->firstWagon == nullptr) {      // Если firstWagon = nullptr, значит состав пустой
        cout << "  Вагонов нет" << endl;
    }
    else {
        // 4. Если вагоны есть, проходим по всем и выводим информацию
        // Начинаем с первого вагона
        Wagon* p = loco->firstWagon;
        // Создаём счётчики
        int count = 0;        // Количество вагонов
        int totalWeight = 0;  // Общий вес всех вагонов
        while (p != nullptr) {
            count++;                  // Увеличиваем счётчик вагонов
            totalWeight += p->weight; // Добавляем вес текущего вагона
            // Выводим информацию о текущем вагоне
            cout << "  Вагон " << count << ": Номер" << p->number
                << ", груз: " << p->cargo
                << ", вес: " << p->weight << "т" << endl;
            // Переходим к следующему вагону в цепочке
            p = p->next;
        }
        // 5. Выводим итоговую статистику
        cout << "  Итого: " << count << " вагонов, общий вес: "
            << totalWeight << "т" << endl;
    }
}

// Функция отцепки последнего вагона от локомотива
void DETACH_LAST(Locomotive* loco) {
    // 1. Проверки
    if (loco == nullptr || loco->firstWagon == nullptr) {
        cout << "Нечего отцеплять!" << endl;
        return;
    }
    // 2. Если у локомотива ТОЛЬКО ОДИН вагон
    if (loco->firstWagon->next == nullptr) {     //    Если следующий за первым вагоном = nullptr, значит вагон всего один
        // Какой вагон отцепляем
        cout << "Отцеплен вагон Номер" << loco->firstWagon->number << endl;
        // Освобождаем память занятую этим вагоном
        delete loco->firstWagon;
        loco->firstWagon = nullptr;
        return;  
    }
    // Если вагонов несколько
    Wagon* p = loco->firstWagon;
    while (p->next->next != nullptr) {
        p = p->next;  // Переходим к следующему вагону
    }
    // Теперь p указывает на предпоследний вагон
    // 3.3. Сообщаем какой вагон отцепляем (последний)
    cout << "Отцеплен вагон Номер" << p->next->number << endl;
    // Освобождаем память последнего вагона
    delete p->next;
    // Теперь предпоследний вагон стал последним. Устанавливаем его указатель next в nullptr
    p->next = nullptr;
}

// Функция поиска локомотива по его коду
Locomotive* FIND_LOCO(Locomotive* head, char code) {
    // 1. Начинаем поиск с начала списка
    Locomotive* p = head;
    // 2. Проходим по всему списку локомотивов
    while (p != nullptr) {
        // 3. Проверяем код текущего локомотива совпадает с искомым
        if (p->code == code) {
            return p;  // Нашли, возвращаем указатель на этот локомотив
        }
        // 4. Переходим к следующему локомотиву в списке
        p = p->next;
    }
    // 5. Локомотив не найден
    return nullptr;
}

// Функция вывода ВСЕХ локомотивов и их составов
void PRINT_ALL(Locomotive* head) {
    // 1. Начинаем с первого локомотива
    Locomotive* p = head;
    // 2. Проходим по всем локомотивам в списке
    while (p != nullptr) {
        // 3. Для каждого локомотива вызываем функцию просмотра
        VIEW_LOCO(p);
        cout << endl;
        // 4. Переходим к следующему локомотиву
        p = p->next;
    }
}
// Функция инициализации тестовых данных
// Создаёт 3 локомотива и 9 вагонов, распределяет вагоны по составам
void INIT_TRAINS(Locomotive*& head) {
    // 1. Создаём 3 локомотива
    head = MAKE_LOCO('A');        // Локомотив A
    Locomotive* locoB = MAKE_LOCO('B');  // Локомотив B
    Locomotive* locoC = MAKE_LOCO('C');  // Локомотив C

    // 2. Связываем локомотивы в список: A → B → C
    head->next = locoB;    // После A идёт B
    locoB->next = locoC;   // После B идёт C
    // 3. Прицепляем вагоны к локомотиву A (3 вагона)
    ATTACH_WAGON(head, 100, "Уголь", 75);
    ATTACH_WAGON(head, 101, "Нефть", 68);
    ATTACH_WAGON(head, 102, "Зерно", 50);

    // 4. Прицепляем вагоны к локомотиву B (4 вагона)
    ATTACH_WAGON(locoB, 200, "Автомобили", 40);
    ATTACH_WAGON(locoB, 201, "Контейнеры", 55);
    ATTACH_WAGON(locoB, 202, "Лес", 60);
    ATTACH_WAGON(locoB, 203, "Химикаты", 45);

    // 5. Прицепляем вагоны к локомотиву C (3 вагона)
    ATTACH_WAGON(locoC, 300, "Металл", 70);
    ATTACH_WAGON(locoC, 301, "Песок", 65);
    ATTACH_WAGON(locoC, 302, "Щебень", 58);
}

// Функция освобождения всей выделенной памяти
void CLEANUP(Locomotive* head) {
    // 1. Начинаем с первого локомотива
    Locomotive* loco = head;
    // 2. Проходим по всем локомотивам
    while (loco != nullptr) {
        // 3. Для каждого локомотива удаляем ВСЕ его вагоны
        // Начинаем с первого вагона локомотива
        Wagon* wagon = loco->firstWagon;
        // Проходим по всем вагонам локомотива
        while (wagon != nullptr) {
            // Запоминаем текущий вагон во временной переменной
            Wagon* temp = wagon;
            // Переходим к следующему вагону ПЕРЕД удалением
            wagon = wagon->next;
            delete temp;
        }
        // 4. Удаляем сам локомотив
        // Запоминаем текущий локомотив во временной переменной
        Locomotive* tempLoco = loco;
        // Переходим к следующему локомотиву ПЕРЕД удалением
        loco = loco->next;
        // Удаляем запомненный локомотив
        delete tempLoco;
    }
}

int main() {
    setlocale(LC_ALL, "Russian");
    // 1. Объявляем указатель на первый локомотив в списке
    Locomotive* trains = nullptr;
    // 2. Создаём 3 локомотива и 10 вагонов
    INIT_TRAINS(trains);
    // 3. Переменная для выбора пользователя в меню
    int choice;
    // 4. Начинаем основной цикл программы с меню
    do {
        // Выводим меню
        cout << "\n МЕНЮ " << endl;
        cout << "1 - Просмотреть состав" << endl;
        cout << "2 - Создать новый локомотив" << endl;
        cout << "3 - Создать новый вагон" << endl;
        cout << "4 - Вывод всех составов" << endl;
        cout << "5 - Отцепить последний вагон" << endl;
        cout << "0 - Выход" << endl;
        cout << endl;
        cout << "Выберите: ";
        // Делаем выбор
        cin >> choice;
        switch (choice) {
            // ПУНКТ 1: Просмотреть состав конкретного локомотива
        case 1: {
            // Запрашиваем код локомотива
            char code;
            cout << "Введите код локомотива (A-Z): ";
            cin >> code;
            // Ищем локомотив с таким кодом
            Locomotive* loco = FIND_LOCO(trains, code);
            VIEW_LOCO(loco);
            break;
        }
              // ПУНКТ 2: Создать новый локомотив
        case 2: {
            // Запрашиваем код нового локомотива
            char code;
            cout << "Введите код нового локомотива (A-Z): ";
            cin >> code;
            // Проверяем нет ли уже локомотива с таким кодом
            if (FIND_LOCO(trains, code) != nullptr) {
                cout << "Локомотив с таким кодом уже существует!" << endl;
                break; 
            }
            // Создаём новый локомотив
            Locomotive* newLoco = MAKE_LOCO(code);
            newLoco->next = trains;  // Новый указывает на старый первый
            trains = newLoco;        // Теперь новый стал первым
            cout << "Локомотив [" << code << "] создан!" << endl;
            break;
        }
              // ПУНКТ 3: Создать новый вагон и прицепить к локомотиву
        case 3: {
            // Объявляем переменные для данных вагона
            char code;      // Код локомотива, к которому цепляем
            int number;     // Номер вагона
            string cargo;   // Тип груза
            int weight;     // Вес вагона
            // Запрашиваем код локомотива
            cout << "К какому локомотиву прицепить (код A-Z): ";
            cin >> code;
            // Ищем локомотив
            Locomotive* loco = FIND_LOCO(trains, code);
            // Проверяем найден ли локомотив
            if (loco == nullptr) {
                cout << "Локомотив не найден!" << endl;
                break; 
            }
            // Запрашиваем номер вагона
            cout << "Номер вагона (0-999): ";
            cin >> number;
            // Проверяем корректность номера (по условию задачи)
            if (number < 0 || number > 999) {
                cout << "Некорректный номер!" << endl;
                break;
            }
            // Запрашиваем тип груза
            cout << "Груз: ";
            cin.ignore();      
            getline(cin, cargo); // Считываем строку с пробелами
            // Запрашиваем вес
            cout << "Вес (тонны): ";
            cin >> weight;
            // Прицепляем вагон к найденному локомотиву
            ATTACH_WAGON(loco, number, cargo, weight);
            // Сообщаем об успехе
            cout << "Вагон добавлен к локомотиву [" << code << "]" << endl;
            break;
        }

              // ПУНКТ 4: Вывести все составы
        case 4: {
            // Проверяем есть ли вообще локомотивы
            if (trains == nullptr) {
                cout << "Локомотивов нет!" << endl;
            }
            else {
                // Выводим все локомотивы и их составы
                PRINT_ALL(trains);
            }
            break;
        }

              // ПУНКТ 5: Отцепить последний вагон
        case 5: {
            // Запрашиваем код локомотива
            char code;
            cout << "От какого локомотива отцепить (код A-Z): ";
            cin >> code;
            // Ищем локомотив
            Locomotive* loco = FIND_LOCO(trains, code);
            // Если нашли - отцепляем последний вагон
            if (loco != nullptr) {
                DETACH_LAST(loco);
            }
            else {
                // Если не нашли - сообщаем об ошибке
                cout << "Локомотив не найден" << endl;
            }
            break;
        }

              // ПУНКТ 0: Выход из программы
        case 0:
            cout << "Выход..." << endl;
            break;
            // Обработка неверного ввода
        default:
            cout << "Неверная команда!" << endl;
        }

        // 5. Цикл продолжается, пока пользователь не выберет 0
    } while (choice != 0);

    // 6. Перед завершением программы освобождаем всю память
    CLEANUP(trains);
    return 0;
}